The architecture of a compiler is fundamentally divided into two main phases: the **analysis phase** and the **synthesis phase**. This separation, also known as the **front end** and **back end**, respectively, is a standard design principle that makes compilers more modular and efficient.

***

### Analysis Phase (Front End) üßê

The analysis phase is the first part of the compilation process. Its primary job is to analyze the source code and create an intermediate representation (IR) of the program. This phase is largely **language-dependent**, meaning it's specific to the programming language being compiled. It is concerned with understanding the structure and meaning of the source code.

This phase is typically broken down into three sub-phases:

1.  **Lexical Analysis (Scanning):** The source code is read character by character and grouped into meaningful units called **tokens**. It removes whitespace and comments. For example, the statement `int sum = a + b;` is broken down into tokens like `int`, `sum`, `=`, `a`, `+`, `b`, and `;`.
2.  **Syntax Analysis (Parsing):** This phase takes the stream of tokens and checks if they form a grammatically correct structure according to the language's rules. It builds a hierarchical representation of the code, often a **parse tree** or an **Abstract Syntax Tree (AST)**. If the syntax is incorrect, it reports an error. 
3.  **Semantic Analysis:** This phase goes beyond syntax to verify the logical correctness and meaning of the code. It checks for **semantic errors** like type mismatches (e.g., trying to add a string to an integer), using an undeclared variable, or calling a function with the wrong number of arguments. It also populates the **symbol table** with information about variables and functions.

***

### Synthesis Phase (Back End) ‚öôÔ∏è

The synthesis phase takes the intermediate representation (IR) generated by the analysis phase and translates it into the final target code. This phase is largely **machine-dependent**, meaning it's tailored to a specific hardware architecture. The goal is to generate efficient, optimized code for the target machine.

This phase also consists of several sub-phases:

1.  **Intermediate Code Generation:** A low-level, machine-like intermediate code is generated from the AST. This representation is independent of the source language and the target machine, making it easier to perform optimizations.
2.  **Code Optimization:** This is an optional but critical phase. It transforms the intermediate code to make it more efficient and faster. Optimizations include rearranging instructions, removing redundant code (**dead code elimination**), and leveraging specialized hardware features.
3.  **Code Generation:** In the final step, the optimized intermediate code is translated into the final **target machine code** (e.g., assembly language or binary). This involves making crucial decisions about which variables go into which CPU registers and how to manage memory.